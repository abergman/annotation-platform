"""
WebSocket API for Real-time Batch Operation Updates

Provides real-time updates for batch operations progress, status changes,
and completion notifications via WebSocket connections.
"""

import asyncio
import json
import logging
from typing import Dict, List, Optional, Set
from datetime import datetime

from fastapi import WebSocket, WebSocketDisconnect, Depends, HTTPException, status
from fastapi.routing import APIRouter

from src.core.security import get_current_user
from src.models.user import User
from src.utils.progress_tracker import ProgressTracker
from src.utils.batch_processor import BatchProcessor

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/api/v1/batch/ws", tags=["batch-websocket"])

# Global instances
progress_tracker = ProgressTracker()
batch_processor = BatchProcessor()


class ConnectionManager:
    """Manage WebSocket connections for batch operation updates."""
    
    def __init__(self):
        self.active_connections: Dict[str, WebSocket] = {}
        self.user_connections: Dict[int, Set[str]] = {}  # user_id -> connection_ids
        self.operation_subscribers: Dict[str, Set[str]] = {}  # operation_id -> connection_ids
        self.connection_metadata: Dict[str, Dict] = {}  # connection_id -> metadata
    
    async def connect(self, websocket: WebSocket, connection_id: str, user: User):
        """Accept a new WebSocket connection."""
        await websocket.accept()
        
        self.active_connections[connection_id] = websocket
        
        # Track user connections
        if user.id not in self.user_connections:
            self.user_connections[user.id] = set()
        self.user_connections[user.id].add(connection_id)
        
        # Store connection metadata
        self.connection_metadata[connection_id] = {\n            \"user_id\": user.id,\n            \"username\": user.username,\n            \"connected_at\": datetime.utcnow(),\n            \"subscriptions\": set()\n        }\n        \n        # Register with progress tracker\n        progress_tracker.add_websocket_connection(websocket)\n        \n        logger.info(f\"WebSocket connection established: {connection_id} for user {user.id}\")\n    \n    def disconnect(self, connection_id: str):\n        \"\"\"Remove a WebSocket connection.\"\"\"\n        if connection_id in self.active_connections:\n            websocket = self.active_connections[connection_id]\n            metadata = self.connection_metadata.get(connection_id, {})\n            user_id = metadata.get(\"user_id\")\n            \n            # Remove from active connections\n            del self.active_connections[connection_id]\n            \n            # Remove from user connections\n            if user_id and user_id in self.user_connections:\n                self.user_connections[user_id].discard(connection_id)\n                if not self.user_connections[user_id]:\n                    del self.user_connections[user_id]\n            \n            # Remove from operation subscriptions\n            for operation_id, subscribers in self.operation_subscribers.items():\n                subscribers.discard(connection_id)\n            \n            # Remove from progress tracker\n            progress_tracker.remove_websocket_connection(websocket)\n            \n            # Remove metadata\n            if connection_id in self.connection_metadata:\n                del self.connection_metadata[connection_id]\n            \n            logger.info(f\"WebSocket connection closed: {connection_id}\")\n    \n    async def send_personal_message(self, message: dict, connection_id: str):\n        \"\"\"Send a message to a specific connection.\"\"\"\n        if connection_id in self.active_connections:\n            websocket = self.active_connections[connection_id]\n            try:\n                await websocket.send_text(json.dumps(message))\n            except Exception as e:\n                logger.error(f\"Failed to send message to {connection_id}: {str(e)}\")\n                self.disconnect(connection_id)\n    \n    async def broadcast_to_user(self, message: dict, user_id: int):\n        \"\"\"Send a message to all connections of a specific user.\"\"\"\n        if user_id in self.user_connections:\n            connection_ids = list(self.user_connections[user_id])\n            for connection_id in connection_ids:\n                await self.send_personal_message(message, connection_id)\n    \n    async def broadcast_to_operation_subscribers(self, message: dict, operation_id: str):\n        \"\"\"Send a message to all subscribers of an operation.\"\"\"\n        if operation_id in self.operation_subscribers:\n            connection_ids = list(self.operation_subscribers[operation_id])\n            for connection_id in connection_ids:\n                await self.send_personal_message(message, connection_id)\n    \n    async def broadcast_to_all(self, message: dict):\n        \"\"\"Send a message to all active connections.\"\"\"\n        connection_ids = list(self.active_connections.keys())\n        for connection_id in connection_ids:\n            await self.send_personal_message(message, connection_id)\n    \n    def subscribe_to_operation(self, connection_id: str, operation_id: str):\n        \"\"\"Subscribe a connection to operation updates.\"\"\"\n        if operation_id not in self.operation_subscribers:\n            self.operation_subscribers[operation_id] = set()\n        \n        self.operation_subscribers[operation_id].add(connection_id)\n        \n        # Update connection metadata\n        if connection_id in self.connection_metadata:\n            self.connection_metadata[connection_id][\"subscriptions\"].add(operation_id)\n        \n        logger.info(f\"Connection {connection_id} subscribed to operation {operation_id}\")\n    \n    def unsubscribe_from_operation(self, connection_id: str, operation_id: str):\n        \"\"\"Unsubscribe a connection from operation updates.\"\"\"\n        if operation_id in self.operation_subscribers:\n            self.operation_subscribers[operation_id].discard(connection_id)\n            \n            # Clean up empty subscription sets\n            if not self.operation_subscribers[operation_id]:\n                del self.operation_subscribers[operation_id]\n        \n        # Update connection metadata\n        if connection_id in self.connection_metadata:\n            self.connection_metadata[connection_id][\"subscriptions\"].discard(operation_id)\n        \n        logger.info(f\"Connection {connection_id} unsubscribed from operation {operation_id}\")\n    \n    def get_connection_stats(self) -> Dict:\n        \"\"\"Get connection statistics.\"\"\"\n        return {\n            \"total_connections\": len(self.active_connections),\n            \"users_connected\": len(self.user_connections),\n            \"operations_subscribed\": len(self.operation_subscribers),\n            \"connections_per_user\": {\n                user_id: len(connections) \n                for user_id, connections in self.user_connections.items()\n            },\n            \"subscribers_per_operation\": {\n                operation_id: len(subscribers)\n                for operation_id, subscribers in self.operation_subscribers.items()\n            }\n        }\n\n\n# Global connection manager\nmanager = ConnectionManager()\n\n\n@router.websocket(\"/connect\")\nasync def websocket_endpoint(\n    websocket: WebSocket,\n    token: Optional[str] = None\n):\n    \"\"\"\n    WebSocket endpoint for real-time batch operation updates.\n    \n    Protocol:\n    - Client sends: {\"action\": \"authenticate\", \"token\": \"jwt_token\"}\n    - Client sends: {\"action\": \"subscribe\", \"operation_id\": \"uuid\"}\n    - Client sends: {\"action\": \"unsubscribe\", \"operation_id\": \"uuid\"}\n    - Client sends: {\"action\": \"get_status\", \"operation_id\": \"uuid\"}\n    - Client sends: {\"action\": \"list_operations\"}\n    \n    - Server sends: {\"type\": \"progress_update\", \"operation_id\": \"uuid\", \"data\": {...}}\n    - Server sends: {\"type\": \"operation_completed\", \"operation_id\": \"uuid\", \"data\": {...}}\n    - Server sends: {\"type\": \"operation_failed\", \"operation_id\": \"uuid\", \"data\": {...}}\n    - Server sends: {\"type\": \"status_response\", \"operation_id\": \"uuid\", \"data\": {...}}\n    \"\"\"\n    connection_id = f\"ws_{datetime.utcnow().timestamp()}_{id(websocket)}\"\n    user = None\n    \n    try:\n        # Initial connection without authentication\n        await websocket.accept()\n        \n        # Send connection established message\n        await websocket.send_text(json.dumps({\n            \"type\": \"connection_established\",\n            \"connection_id\": connection_id,\n            \"timestamp\": datetime.utcnow().isoformat(),\n            \"message\": \"WebSocket connection established. Please authenticate.\"\n        }))\n        \n        while True:\n            # Receive message from client\n            data = await websocket.receive_text()\n            message = json.loads(data)\n            \n            action = message.get(\"action\")\n            \n            if action == \"authenticate\":\n                # Authenticate user\n                token = message.get(\"token\")\n                if not token:\n                    await websocket.send_text(json.dumps({\n                        \"type\": \"error\",\n                        \"message\": \"Authentication token required\"\n                    }))\n                    continue\n                \n                try:\n                    # Verify token and get user\n                    from src.core.security import verify_token\n                    from src.core.database import SessionLocal\n                    from src.models.user import User\n                    \n                    payload = verify_token(token)\n                    if not payload:\n                        raise HTTPException(status_code=401, detail=\"Invalid token\")\n                    \n                    username = payload.get(\"sub\")\n                    if not username:\n                        raise HTTPException(status_code=401, detail=\"Invalid token payload\")\n                    \n                    db = SessionLocal()\n                    try:\n                        user = db.query(User).filter(User.username == username).first()\n                        if not user or not user.is_active:\n                            raise HTTPException(status_code=401, detail=\"User not found or inactive\")\n                    finally:\n                        db.close()\n                    \n                    # Register authenticated connection\n                    await manager.connect(websocket, connection_id, user)\n                    \n                    # Send authentication success\n                    await websocket.send_text(json.dumps({\n                        \"type\": \"authenticated\",\n                        \"user_id\": user.id,\n                        \"username\": user.username,\n                        \"connection_id\": connection_id,\n                        \"timestamp\": datetime.utcnow().isoformat()\n                    }))\n                    \n                except Exception as e:\n                    await websocket.send_text(json.dumps({\n                        \"type\": \"authentication_failed\",\n                        \"message\": str(e)\n                    }))\n                    continue\n            \n            elif action == \"subscribe\":\n                if not user:\n                    await websocket.send_text(json.dumps({\n                        \"type\": \"error\",\n                        \"message\": \"Authentication required\"\n                    }))\n                    continue\n                \n                operation_id = message.get(\"operation_id\")\n                if operation_id:\n                    manager.subscribe_to_operation(connection_id, operation_id)\n                    await websocket.send_text(json.dumps({\n                        \"type\": \"subscribed\",\n                        \"operation_id\": operation_id,\n                        \"timestamp\": datetime.utcnow().isoformat()\n                    }))\n            \n            elif action == \"unsubscribe\":\n                if not user:\n                    await websocket.send_text(json.dumps({\n                        \"type\": \"error\",\n                        \"message\": \"Authentication required\"\n                    }))\n                    continue\n                \n                operation_id = message.get(\"operation_id\")\n                if operation_id:\n                    manager.unsubscribe_from_operation(connection_id, operation_id)\n                    await websocket.send_text(json.dumps({\n                        \"type\": \"unsubscribed\",\n                        \"operation_id\": operation_id,\n                        \"timestamp\": datetime.utcnow().isoformat()\n                    }))\n            \n            elif action == \"get_status\":\n                if not user:\n                    await websocket.send_text(json.dumps({\n                        \"type\": \"error\",\n                        \"message\": \"Authentication required\"\n                    }))\n                    continue\n                \n                operation_id = message.get(\"operation_id\")\n                if operation_id:\n                    # Get operation status\n                    status_data = progress_tracker.get_progress(operation_id)\n                    performance_metrics = batch_processor.get_performance_metrics(operation_id)\n                    \n                    response = {\n                        \"type\": \"status_response\",\n                        \"operation_id\": operation_id,\n                        \"data\": status_data,\n                        \"performance_metrics\": performance_metrics,\n                        \"timestamp\": datetime.utcnow().isoformat()\n                    }\n                    \n                    await websocket.send_text(json.dumps(response))\n            \n            elif action == \"list_operations\":\n                if not user:\n                    await websocket.send_text(json.dumps({\n                        \"type\": \"error\",\n                        \"message\": \"Authentication required\"\n                    }))\n                    continue\n                \n                # Get user's active operations\n                active_operations = progress_tracker.get_active_operations()\n                \n                # Filter by user (if not admin)\n                if not user.is_admin:\n                    # This would require adding user_id to progress tracker\n                    pass\n                \n                response = {\n                    \"type\": \"operations_list\",\n                    \"operations\": active_operations,\n                    \"timestamp\": datetime.utcnow().isoformat()\n                }\n                \n                await websocket.send_text(json.dumps(response))\n            \n            elif action == \"get_stats\":\n                if not user:\n                    await websocket.send_text(json.dumps({\n                        \"type\": \"error\",\n                        \"message\": \"Authentication required\"\n                    }))\n                    continue\n                \n                # Get connection statistics (admin only)\n                if user.is_admin:\n                    stats = manager.get_connection_stats()\n                    response = {\n                        \"type\": \"stats_response\",\n                        \"data\": stats,\n                        \"timestamp\": datetime.utcnow().isoformat()\n                    }\n                    await websocket.send_text(json.dumps(response))\n                else:\n                    await websocket.send_text(json.dumps({\n                        \"type\": \"error\",\n                        \"message\": \"Admin access required\"\n                    }))\n            \n            elif action == \"ping\":\n                # Heartbeat/ping response\n                await websocket.send_text(json.dumps({\n                    \"type\": \"pong\",\n                    \"timestamp\": datetime.utcnow().isoformat()\n                }))\n            \n            else:\n                await websocket.send_text(json.dumps({\n                    \"type\": \"error\",\n                    \"message\": f\"Unknown action: {action}\"\n                }))\n    \n    except WebSocketDisconnect:\n        logger.info(f\"WebSocket client disconnected: {connection_id}\")\n    except Exception as e:\n        logger.error(f\"WebSocket error for {connection_id}: {str(e)}\")\n    finally:\n        manager.disconnect(connection_id)\n\n\n@router.get(\"/stats\")\nasync def get_websocket_stats(\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get WebSocket connection statistics.\n    Admin only endpoint.\n    \"\"\"\n    if not current_user.is_admin:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Admin access required\"\n        )\n    \n    stats = manager.get_connection_stats()\n    \n    return {\n        \"websocket_stats\": stats,\n        \"timestamp\": datetime.utcnow().isoformat()\n    }\n\n\n@router.post(\"/broadcast\")\nasync def broadcast_message(\n    message: str,\n    operation_id: Optional[str] = None,\n    user_id: Optional[int] = None,\n    current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Broadcast a message via WebSocket.\n    Admin only endpoint for system messages.\n    \"\"\"\n    if not current_user.is_admin:\n        raise HTTPException(\n            status_code=status.HTTP_403_FORBIDDEN,\n            detail=\"Admin access required\"\n        )\n    \n    broadcast_message = {\n        \"type\": \"system_message\",\n        \"message\": message,\n        \"from_user\": current_user.username,\n        \"timestamp\": datetime.utcnow().isoformat()\n    }\n    \n    try:\n        if operation_id:\n            await manager.broadcast_to_operation_subscribers(broadcast_message, operation_id)\n            target = f\"operation {operation_id} subscribers\"\n        elif user_id:\n            await manager.broadcast_to_user(broadcast_message, user_id)\n            target = f\"user {user_id}\"\n        else:\n            await manager.broadcast_to_all(broadcast_message)\n            target = \"all connected users\"\n        \n        return {\n            \"message\": \"Broadcast sent successfully\",\n            \"target\": target,\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        \n    except Exception as e:\n        logger.error(f\"Broadcast failed: {str(e)}\")\n        raise HTTPException(\n            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,\n            detail=f\"Broadcast failed: {str(e)}\"\n        )\n\n\nclass BatchWebSocketNotifier:\n    \"\"\"\n    Utility class for sending batch operation notifications via WebSocket.\n    \"\"\"\n    \n    @staticmethod\n    async def notify_operation_started(operation_id: str, user_id: int, operation_data: dict):\n        \"\"\"Notify that a batch operation has started.\"\"\"\n        message = {\n            \"type\": \"operation_started\",\n            \"operation_id\": operation_id,\n            \"data\": operation_data,\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        \n        await manager.broadcast_to_user(message, user_id)\n        await manager.broadcast_to_operation_subscribers(message, operation_id)\n    \n    @staticmethod\n    async def notify_operation_progress(operation_id: str, progress_data: dict):\n        \"\"\"Notify about operation progress updates.\"\"\"\n        message = {\n            \"type\": \"progress_update\",\n            \"operation_id\": operation_id,\n            \"data\": progress_data,\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        \n        await manager.broadcast_to_operation_subscribers(message, operation_id)\n    \n    @staticmethod\n    async def notify_operation_completed(operation_id: str, result_data: dict):\n        \"\"\"Notify that a batch operation has completed.\"\"\"\n        message = {\n            \"type\": \"operation_completed\",\n            \"operation_id\": operation_id,\n            \"data\": result_data,\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        \n        await manager.broadcast_to_operation_subscribers(message, operation_id)\n    \n    @staticmethod\n    async def notify_operation_failed(operation_id: str, error_data: dict):\n        \"\"\"Notify that a batch operation has failed.\"\"\"\n        message = {\n            \"type\": \"operation_failed\",\n            \"operation_id\": operation_id,\n            \"data\": error_data,\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        \n        await manager.broadcast_to_operation_subscribers(message, operation_id)\n    \n    @staticmethod\n    async def notify_operation_cancelled(operation_id: str):\n        \"\"\"Notify that a batch operation has been cancelled.\"\"\"\n        message = {\n            \"type\": \"operation_cancelled\",\n            \"operation_id\": operation_id,\n            \"timestamp\": datetime.utcnow().isoformat()\n        }\n        \n        await manager.broadcast_to_operation_subscribers(message, operation_id)\n\n\n# Export the notifier for use in other modules\nwebsocket_notifier = BatchWebSocketNotifier()